#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ROWS 5
#define COLS 5
#define MAX_ZONES 100

// Field cell types
#define HEALTHY 0
#define DROUGHT 1
#define INSECT 2
#define OBSTACLE 3

// Threat zone structure
typedef struct {
    int x, y;
    int type; // 1 = Drought, 2 = Insect
} ThreatZone;

// Linked list for drone task logs
typedef struct Log {
    char message[100];
    struct Log* next;
} Log;

Log* head = NULL;

void addLog(const char* msg) {
    Log* newLog = (Log*)malloc(sizeof(Log));
    strcpy(newLog->message, msg);
    newLog->next = head;
    head = newLog;
}

void printLogs() {
    printf("\n📋 Drone Logs:\n");
    Log* temp = head;
    while (temp != NULL) {
        printf("%s\n", temp->message);
        temp = temp->next;
    }
}

// Threat zone comparator for sorting
int compareThreats(const void* a, const void* b) {
    ThreatZone* t1 = (ThreatZone*)a;
    ThreatZone* t2 = (ThreatZone*)b;
    return t1->type - t2->type; // Drought (1) comes before Insect (2)
}

// Check bounds
int isValid(int x, int y, int field[ROWS][COLS], int visited[ROWS][COLS]) {
    return x >= 0 && x < ROWS && y >= 0 && y < COLS && field[x][y] != OBSTACLE && !visited[x][y];
}

// DFS for field coverage
void dfs(int x, int y, int field[ROWS][COLS], int visited[ROWS][COLS]) {
    static int dx[] = {-1, 1, 0, 0};
    static int dy[] = {0, 0, -1, 1};

    visited[x][y] = 1;
    char log[100];

    if (field[x][y] == DROUGHT)
        sprintf(log, "[Drone] Checked (%d,%d) - Drought", x, y);
    else if (field[x][y] == INSECT)
        sprintf(log, "[Drone] Checked (%d,%d) - Insect", x, y);
    else
        sprintf(log, "[Drone] Checked (%d,%d) - Healthy", x, y);

    addLog(log);

    for (int i = 0; i < 4; i++) {
        int newX = x + dx[i];
        int newY = y + dy[i];
        if (isValid(newX, newY, field, visited)) {
            dfs(newX, newY, field, visited);
        }
    }
}

// BFS to find shortest path to base (0,0)
int bfsToBase(int field[ROWS][COLS], int startX, int startY) {
    int visited[ROWS][COLS] = {0};
    int dist[ROWS][COLS] = {0};

    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    int queueX[ROWS * COLS], queueY[ROWS * COLS];
    int front = 0, rear = 0;

    queueX[rear] = startX;
    queueY[rear] = startY;
    rear++;
    visited[startX][startY] = 1;

    while (front < rear) {
        int x = queueX[front];
        int y = queueY[front];
        front++;

        if (x == 0 && y == 0)
            return dist[x][y];

        for (int i = 0; i < 4; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];

            if (isValid(newX, newY, field, visited)) {
                visited[newX][newY] = 1;
                dist[newX][newY] = dist[x][y] + 1;
                queueX[rear] = newX;
                queueY[rear] = newY;
                rear++;
            }
        }
    }

    return -1; // No path
}

int main() {
    int field[ROWS][COLS] = {
        {0, 0, 2, 0, 1},
        {0, 3, 0, 2, 0},
        {0, 0, 1, 0, 0},
        {1, 3, 2, 0, 0},
        {0, 0, 0, 1, 0}
    };

    int visited[ROWS][COLS] = {0};
    ThreatZone threats[MAX_ZONES];
    int threatCount = 0;

    printf("🚁 Drone Starting Inspection from (0,0)...\n\n");
    dfs(0, 0, field, visited);

    // Collect threats
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (field[i][j] == DROUGHT || field[i][j] == INSECT) {
                threats[threatCount].x = i;
                threats[threatCount].y = j;
                threats[threatCount].type = field[i][j];
                threatCount++;
            }
        }
    }

    qsort(threats, threatCount, sizeof(ThreatZone), compareThreats);

    printf("\n🌾 Threat Zone Priority:\n");
    for (int i = 0; i < threatCount; i++) {
        printf("%d. Zone (%d,%d) - %s\n", i + 1, threats[i].x, threats[i].y,
            (threats[i].type == DROUGHT) ? "Drought" : "Insect");
    }

    int lastX = threats[0].x;
    int lastY = threats[0].y;
    int dist = bfsToBase(field, lastX, lastY);
    if (dist != -1) {
        printf("\n📡 Distance from Zone (%d,%d) to Base (0,0): %d\n", lastX, lastY, dist);
    } else {
        printf("\n⚠️ No path to base from (%d,%d)!\n", lastX, lastY);
    }

    printLogs();

    return 0;
}
